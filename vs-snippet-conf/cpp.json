{
    "cpt-b": {
      "prefix": "cpt-b",
      "body": [
        "#include <bits/stdc++.h>\r",
        "\r",
        "#define mx 10000\r",
        "#define mod 1000007\r",
        "#define ll long long\r",
        "\r",
        "using namespace std;\r",
        "\r",
        "// fill_n(&a[0][0], ntc * ntc, -100);\r",
        "\r",
        "void optimize()\r",
        "{\r",
        "    ios_base::sync_with_stdio(0);\r",
        "    cin.tie(0);\r",
        "}\r",
        "\r",
        "void setupFileIO(string fin = \"input.txt\", string fout = \"output.txt\")\r",
        "{\r",
        "    freopen(fin.c_str(), \"r\", stdin);\r",
        "    freopen(fout.c_str(), \"w\", stdout);\r",
        "}\r",
        "\r",
        "void solve()\r",
        "{\r",
        "\r",
        "    int ntc;\r",
        "    cin >> ntc;\r",
        "\r",
        "    for (int tc = 0; tc < ntc; tc++)\r",
        "    {\r",
        "        string s;\r",
        "        cin >> s;\r",
        "        cout << s << \"\\n\";\r",
        "    }\r",
        "}\r",
        "\r",
        "int main()\r",
        "{\r",
        "    optimize();\r",
        "\r",
        "    solve();\r",
        "\r",
        "    return 0;\r",
        "}"
      ]
    },
    "grid-way4": {
      "prefix": "grid-way4",
      "body": [
        "#define way4                               \\\r",
        "    (int[4][2])                            \\\r",
        "    {                                      \\\r",
        "        {0, 1}, {1, 0}, {0, -1}, { -1, 0 } \\\r",
        "    }"
      ],
      "description": "4 way in grid"
    },
    "trie-cpp": {
      "prefix": "cpp-trie",
      "body": [
        "const int ALPHABET_SIZE = 26;\r",
        "\r",
        "struct TrieNode\r",
        "{\r",
        "    struct TrieNode *children[ALPHABET_SIZE];\r",
        "    bool isEndOfWord;\r",
        "\r",
        "    TrieNode()\r",
        "    {\r",
        "        isEndOfWord = false;\r",
        "        for (int i = 0; i < ALPHABET_SIZE; i++)\r",
        "        {\r",
        "            children[i] = nullptr;\r",
        "        }\r",
        "    }\r",
        "};\r",
        "\r",
        "class Trie\r",
        "{\r",
        "private:\r",
        "    TrieNode *root;\r",
        "\r",
        "public:\r",
        "    Trie()\r",
        "    {\r",
        "        root = new TrieNode();\r",
        "    }\r",
        "\r",
        "    void insert(struct TrieNode *root, string key)\r",
        "    {\r",
        "        struct TrieNode *pCrawl = root;\r",
        "\r",
        "        for (int i = 0; i < key.length(); i++)\r",
        "        {\r",
        "            int index = key[i] - 'a';\r",
        "            if (!pCrawl->children[index])\r",
        "            {\r",
        "                pCrawl->children[index] = new TrieNode();\r",
        "            }\r",
        "            pCrawl = pCrawl->children[index];\r",
        "        }\r",
        "\r",
        "        pCrawl->isEndOfWord = true;\r",
        "    }\r",
        "\r",
        "    bool search(struct TrieNode *root, string key)\r",
        "    {\r",
        "        struct TrieNode *pCrawl = root;\r",
        "\r",
        "        for (int i = 0; i < key.length(); i++)\r",
        "        {\r",
        "            int index = key[i] - 'a';\r",
        "            if (!pCrawl->children[index])\r",
        "                return false;\r",
        "\r",
        "            pCrawl = pCrawl->children[index];\r",
        "        }\r",
        "\r",
        "        return (pCrawl->isEndOfWord);\r",
        "    }\r",
        "\r",
        "    ~Trie()\r",
        "    {\r",
        "        delete root;\r",
        "    }\r",
        "};"
      ],
      "description": "Trie"
    },
    "lowerbound-comparator": {
      "prefix": "lowerbound-comparator",
      "body": [
        "class Solution\r",
        "{\r",
        "public:\r",
        "    static bool comp(const vector<int> &a, const vector<int> &b)\r",
        "    {\r",
        "        return a[0] < b[0];\r",
        "    }\r",
        "\r",
        "    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &newInterval)\r",
        "    {\r",
        "        int l = upper_bound(intervals.begin(), intervals.end(), newInterval, comp) - intervals.begin();\r",
        "        cout << l << \"\\n\";\r",
        "\r",
        "        return intervals;\r",
        "    }\r",
        "};"
      ],
      "description": "Comparator Lower Bound"
    },
    "manchers-algo": {
      "prefix": "manchers-algo",
      "body": [
        "void applyManchers(string s)\r",
        "{\r",
        "    int n = s.size();\r",
        "    string pS = \"#\";\r",
        "    for (int i = 0; i < n; i++)\r",
        "    {\r",
        "        pS += s[i];\r",
        "        pS += \"#\";\r",
        "    }\r",
        "\r",
        "    int N = pS.size(), center = 0, right = 0;\r",
        "    int Z[N + 5];\r",
        "    memset(Z, 0, sizeof Z);\r",
        "\r",
        "    for (int i = 0; i < N; i++)\r",
        "    {\r",
        "        if (i < right)\r",
        "            Z[i] = min(right - i, Z[2 * center - i]);\r",
        "\r",
        "        while (i + Z[i] + 1 < N && i - Z[i] - 1 >= 0 && pS[i + Z[i] + 1] == pS[i - Z[i] - 1])\r",
        "        {\r",
        "            Z[i]++;\r",
        "        }\r",
        "\r",
        "        if (i + Z[i] > right)\r",
        "        {\r",
        "            center = i;\r",
        "            right = +Z[i];\r",
        "        }\r",
        "    }\r",
        "\r",
        "    for (int i = 0; i < N; i++)\r",
        "    {\r",
        "        if (i & 1)\r",
        "            cout << pS[i] << \" \";\r",
        "        else\r",
        "            cout << \"# \";\r",
        "    }\r",
        "    cout << \"\\n\";\r",
        "\r",
        "    for (int i = 0; i < N + 1; i++)\r",
        "    {\r",
        "        cout << Z[i] << \" \";\r",
        "    }\r",
        "}"
      ],
      "description": "manchers-algo"
    },
    "modulo-multiplication": {
      "prefix": "module-multi",
      "body": [
        "int moduloMultiplication(int a, int b)\r",
        "{\r",
        "    int res = 0;\r",
        "    a %= mod;\r",
        "    while (b)\r",
        "    {\r",
        "        if (b & 1)\r",
        "            res = (res + a) % mod;\r",
        "        a = (2 * a) % mod;\r",
        "        b >>= 1;\r",
        "    }\r",
        "\r",
        "    return res;\r",
        "}"
      ],
      "description": "Multiplication Modulo"
    },
    "for:": {
      "prefix": "for:",
      "body": [
        "for (auto num : nums)\r",
        "        {\r",
        "        }"
      ],
      "description": "for:"
    },
    "cpp-trie": {
      "prefix": "cpp-trie",
      "body": [
        "const int ALPHABET_SIZE = 26;\r",
        "\r",
        "struct TrieNode\r",
        "{\r",
        "    struct TrieNode *children[ALPHABET_SIZE];\r",
        "    bool isEndOfWord;\r",
        "\r",
        "    TrieNode()\r",
        "    {\r",
        "        isEndOfWord = false;\r",
        "        for (int i = 0; i < ALPHABET_SIZE; i++)\r",
        "        {\r",
        "            children[i] = nullptr;\r",
        "        }\r",
        "    }\r",
        "};\r",
        "\r",
        "class Trie\r",
        "{\r",
        "private:\r",
        "    TrieNode *root;\r",
        "\r",
        "public:\r",
        "    Trie()\r",
        "    {\r",
        "        root = new TrieNode();\r",
        "    }\r",
        "\r",
        "    void insert(string key)\r",
        "    {\r",
        "        TrieNode *pCrawl = root;\r",
        "\r",
        "        for (int i = 0; i < key.length(); i++)\r",
        "        {\r",
        "            int index = key[i] - 'a';\r",
        "            if (!pCrawl->children[index])\r",
        "            {\r",
        "                pCrawl->children[index] = new TrieNode();\r",
        "            }\r",
        "            pCrawl = pCrawl->children[index];\r",
        "        }\r",
        "\r",
        "        pCrawl->isEndOfWord = true;\r",
        "    }\r",
        "\r",
        "    bool search(string key)\r",
        "    {\r",
        "        struct TrieNode *pCrawl = root;\r",
        "\r",
        "        for (int i = 0; i < key.length(); i++)\r",
        "        {\r",
        "            int index = key[i] - 'a';\r",
        "            if (!pCrawl->children[index])\r",
        "                return false;\r",
        "\r",
        "            pCrawl = pCrawl->children[index];\r",
        "        }\r",
        "\r",
        "        return (pCrawl->isEndOfWord);\r",
        "    }\r",
        "\r",
        "    ~Trie()\r",
        "    {\r",
        "        delete root;\r",
        "    }\r",
        "};"
      ],
      "description": "cpp-trie"
    },
    "trie": {
      "prefix": "trie-latest",
      "body": [
        "const int ALPHABET_SIZE = 26;\r",
        "\r",
        "class TrieNode\r",
        "{\r",
        "    TrieNode *children[ALPHABET_SIZE] = {nullptr};\r",
        "    bool isEndOfWord;\r",
        "\r",
        "    int getIndex(char ch)\r",
        "    {\r",
        "        return ch - 'a';\r",
        "    }\r",
        "\r",
        "    bool doesExist(char ch)\r",
        "    {\r",
        "        return children[getIndex(ch)] != nullptr;\r",
        "    }\r",
        "\r",
        "    TrieNode *getNext(char ch)\r",
        "    {\r",
        "        return children[getIndex(ch)];\r",
        "    }\r",
        "\r",
        "    TrieNode *addNext(char ch)\r",
        "    {\r",
        "        if (!doesExist(ch))\r",
        "            children[getIndex(ch)] = new TrieNode();\r",
        "\r",
        "        return children[getIndex(ch)];\r",
        "    }\r",
        "\r",
        "public:\r",
        "    void insert(string key)\r",
        "    {\r",
        "        TrieNode *pCrawl = this;\r",
        "\r",
        "        int length = key.length();\r",
        "        for (int i = 0; i < length; i++)\r",
        "        {\r",
        "            pCrawl = pCrawl->addNext(key[i]);\r",
        "        }\r",
        "        pCrawl->isEndOfWord = true;\r",
        "    }\r",
        "\r",
        "    bool search(string key)\r",
        "    {\r",
        "        struct TrieNode *pCrawl = this;\r",
        "        int length = key.size();\r",
        "        for (int i = 0; i < length; i++)\r",
        "        {\r",
        "            if (!pCrawl->doesExist(key[i]))\r",
        "                return false;\r",
        "\r",
        "            pCrawl = pCrawl->getNext(key[i]);\r",
        "        }\r",
        "\r",
        "        return pCrawl->isEndOfWord;\r",
        "    }\r",
        "};"
      ],
      "description": "trie-latest"
    },
    "matrix exponential ": {
      "prefix": "mat-exp",
      "body": [
        "class MatrixExponential\r",
        "{\r",
        "private:\r",
        "    void multiply(int a[3][3], int b[3][3], int matrixDegree)\r",
        "    {\r",
        "        int mul[3][3];\r",
        "        for (int i = 0; i < matrixDegree; i++)\r",
        "        {\r",
        "            for (int j = 0; j < matrixDegree; j++)\r",
        "            {\r",
        "                mul[i][j] = 0;\r",
        "                for (int k = 0; k < matrixDegree; k++)\r",
        "                {\r",
        "                    long currentValue = (1LL * a[i][k] * b[k][j]) % modulo;\r",
        "                    mul[i][j] = (currentValue + 1LL * mul[i][j]) % modulo;\r",
        "                }\r",
        "            }\r",
        "        }\r",
        "\r",
        "        this->copy(a, mul, matrixDegree);\r",
        "    }\r",
        "\r",
        "    void copy(int a[3][3], int b[3][3], int matrixDegree)\r",
        "    {\r",
        "        for (int i = 0; i < matrixDegree; i++)\r",
        "        {\r",
        "            for (int j = 0; j < matrixDegree; j++)\r",
        "            {\r",
        "                a[i][j] = b[i][j];\r",
        "            }\r",
        "        }\r",
        "    }\r",
        "\r",
        "public:\r",
        "    void getPowered(int matrix[3][3], int matrixDegree, int power)\r",
        "    {\r",
        "        int resultMatrix[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}; // identity matrix\r",
        "\r",
        "        while (power)\r",
        "        {\r",
        "            if (power & 1)\r",
        "            {\r",
        "                this->multiply(resultMatrix, matrix, matrixDegree);\r",
        "                power--;\r",
        "            }\r",
        "            else\r",
        "            {\r",
        "                this->multiply(matrix, matrix, matrixDegree);\r",
        "                power >>= 1;\r",
        "            }\r",
        "        }\r",
        "\r",
        "        this->copy(matrix, resultMatrix, matrixDegree);\r",
        "    }\r",
        "};"
      ],
      "description": "matrix exponential "
    },
    "x power of n": {
      "prefix": "pow-n",
      "body": [
        "class MatrixExponential\r",
        "{\r",
        "public:\r",
        "    int getPowered(int base, int power)\r",
        "    {\r",
        "        int result = 1;\r",
        "\r",
        "        while (power)\r",
        "        {\r",
        "            if (power & 1)\r",
        "            {\r",
        "                result *= base;\r",
        "                power--;\r",
        "            }\r",
        "            else\r",
        "            {\r",
        "                base *= base;\r",
        "                power >>= 1;\r",
        "            }\r",
        "        }\r",
        "\r",
        "        return result;\r",
        "    }\r",
        "};"
      ],
      "description": "x to the power of n"
    }
  }